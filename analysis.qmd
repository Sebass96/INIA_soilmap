---
title: "Variaci√≥n espacial del √≠ndice de fertilidad del suelo y recomendaciones de fertilizaci√≥n en los cultivos de Mango y Banano en agroecosistemas de la costa norte √°rida peruana"
author: "Sebastian Casas-Ni√±o; "
format:
  html:
    toc: true
    toc-expand: true
    toc-depth: 4
    toc-location: left
    number-sections: true
    self-contained: true
    code-fold: true
    output-file: "ESM_1"
editor_options: 
  chunk_output_type: console
execute: 
  warning: false
  message: false
  echo: true
---

# Project Setup

```{r}
#| label:  setup
library(terra)
library(sf)
library(sp)
library(raster)
library(gstat)
library(randomForest)
library(caret)
library(Metrics)
library(mapview)
library(tidyverse)
source("https://inkaverse.com/setup.r")
```

# Data import

```{r}
gs <- "https://docs.google.com/spreadsheets/d/1lzq2s11NCiQRjGjA-21VjZGS6zXJsBE8dYtj1QnAFEo/edit?gid=843618649#gid=843618649" %>%
  as_sheets_id()

fb <- gs %>%
  range_read(ss = ., sheet = "Data_corregida")

glimpse(fb)
```

## 1. Par√°metros fijos

```{r}
rasters_folder <- "gis/Covariables_alineados/"
points_geojson <- "gis/JSON/soil_samples.geojson"
response_field <- "SQIw"
out_folder <- "SQIw_RK/"
dir.create(out_folder, showWarnings = FALSE, recursive = TRUE)

predictor_names <- c(
  "Elevation", "Slope", "Orientition", "Hillshade",
  "TPI", "TRI", "TWI", "NDVI", "SAVI", "NDWI",
  "Precipitation", "Temperature"
)

## RFE / CV / RF params
set.seed(123)
k_folds <- 5
rfe_sizes <- c(4, 6, 8, 10) # tama√±os candidatos
train_frac <- 0.80 # 80% entrenamiento / 20% prueba

# Modelos candidatos para variograma (autoselecci√≥n)
model_candidates <- c("Sph", "Exp", "Gau", "Mat")
```

# 2. Cargar rasters y verificar nombres 

```{r}
tif_files <- list.files(rasters_folder, pattern = "\\.tif$", full.names = TRUE)
if (length(tif_files) == 0) stop("No encontr√© archivos .tif en la carpeta indicada.")

expected_files <- file.path(rasters_folder, paste0(predictor_names, ".tif"))
missing_files <- expected_files[!file.exists(expected_files)]
if (length(missing_files) > 0) {
  stop(
    "Faltan archivos TIFF esperados. Archivos que no encontr√©:\n",
    paste(basename(missing_files), collapse = ", ")
  )
}

rast_stack <- terra::rast(expected_files)
names(rast_stack) <- predictor_names
print(rast_stack)
```

# 3. Cargar puntos (.geojson)

```{r}
pts_sf <- sf::st_read(points_geojson, quiet = TRUE)
if (!(response_field %in% names(pts_sf))) stop(paste0("El campo '", response_field, "' no existe en el GeoJSON."))

# Asegurar CRS: usar CRS del raster
rast_crs <- terra::crs(rast_stack, proj = TRUE)
if (is.na(rast_crs) || nchar(rast_crs) == 0) {
  warning("El raster no tiene CRS definido. Se asignar√° EPSG:32717 (UTM 17S).")
  terra::crs(rast_stack) <- "EPSG:32718"
  rast_crs <- terra::crs(rast_stack, proj = TRUE)
}
if (is.na(sf::st_crs(pts_sf))) {
  warning("Los puntos no tienen CRS. Se asignar√° EPSG:32717.")
  st_crs(pts_sf) <- 32717
}
if (sf::st_crs(pts_sf)$wkt != rast_crs) {
  pts_sf <- sf::st_transform(pts_sf, crs = rast_crs)
}
```

# 4. Extraer valores raster en los puntos 

```{r}
vals <- terra::extract(rast_stack, vect(pts_sf))
pts_df <- cbind(st_drop_geometry(pts_sf), vals[, -1, drop = FALSE])

# Quitar filas con NA en respuesta o en predictoras
pts_df <- pts_df[!is.na(pts_df[[response_field]]), , drop = FALSE]
complete_cases <- complete.cases(pts_df[, predictor_names])
pts_df <- pts_df[complete_cases, ]

if (nrow(pts_df) < 10) warning("Pocos puntos despu√©s de limpieza ‚Äî procede con precauci√≥n.")
```

# 5. Divisi√≥n Train/Test 80/20 (para evaluaci√≥n)
```{r}
set.seed(123)
train_index <- caret::createDataPartition(pts_df[[response_field]], p = train_frac, list = FALSE)
df_train <- pts_df[train_index, , drop = FALSE]
df_test <- pts_df[-train_index, , drop = FALSE]

cat(
  "N√∫mero de puntos - total:", nrow(pts_df),
  " train:", nrow(df_train), " test:", nrow(df_test), "\n"
)
```

# 6. RFE sobre el conjunto de entrenamiento

```{r}
x_train <- df_train[, predictor_names, drop = FALSE]
y_train <- df_train[[response_field]]

rfe_ctrl <- caret::rfeControl(
  functions = caret::rfFuncs,
  method = "repeatedcv",
  number = k_folds,
  repeats = 1,
  verbose = FALSE
)

set.seed(123)
rfe_res <- caret::rfe(
  x = x_train, y = y_train,
  sizes = rfe_sizes,
  rfeControl = rfe_ctrl
)

cat("RFE completado. Variables seleccionadas:\n")
print(rfe_res$optVariables)
selected_vars <- rfe_res$optVariables
```

# 7. Entrenar RF en el conjunto de entrenamiento (con CV interno)

```{r}
train_ctrl <- caret::trainControl(method = "cv", number = k_folds, savePredictions = "final")
set.seed(123)
rf_fit_train <- caret::train(
  x = x_train[, selected_vars, drop = FALSE],
  y = y_train,
  method = "rf",
  trControl = train_ctrl,
  importance = TRUE
)
print(rf_fit_train)
```

# 8. Evaluaci√≥n en conjunto de prueba (20%)

```{r}
x_test <- df_test[, selected_vars, drop = FALSE]
y_test <- df_test[[response_field]]
pred_test <- predict(rf_fit_train, newdata = x_test)

# M√©tricas test
rmse_test <- Metrics::rmse(y_test, pred_test)
mae_test <- Metrics::mae(y_test, pred_test)
bias_test <- mean(pred_test - y_test, na.rm = TRUE)
r2_test <- cor(y_test, pred_test, use = "complete.obs")^2

metrics_test <- data.frame(RMSE = rmse_test, MAE = mae_test, BIAS = bias_test, R2 = r2_test, n_test = length(y_test))
readr::write_csv(metrics_test, file.path(out_folder, "test_metrics.csv"))
cat("M√©tricas test guardadas en:", file.path(out_folder, "test_metrics.csv"), "\n")

# Guardar tabla test predicted vs observed
test_table <- data.frame(observed = y_test, predicted = pred_test)
readr::write_csv(test_table, file.path(out_folder, "test_predicted_vs_observed.csv"))
```

# # 9. Guardar predicciones CV (del entrenamiento)

```{r}
cv_df <- rf_fit_train$pred
cv_outfile <- file.path(out_folder, "cv_predictions_train.csv")
readr::write_csv(cv_df, cv_outfile)
cat("Predicciones CV (train) guardadas en:", cv_outfile, "\n")
```

# 10. Reentrenar RF sobre TODO el conjunto (train + test) para mapas

```{r}
x_full <- pts_df[, selected_vars, drop = FALSE]
y_full <- pts_df[[response_field]]

set.seed(123)
rf_fit_full <- randomForest::randomForest(x = x_full, y = y_full, importance = TRUE)
```

# 11. Predicci√≥n de la tendencia (RF final) sobre todo el raster

```{r}
cat("\n--- PREDICCI√ìN RANDOM FOREST SOBRE EL RASTER COMPLETO (manejo conservador NA) ---\n")
cat("Variables seleccionadas por RFE:\n")
print(selected_vars)
cat("Variables presentes en el stack raster:\n")
print(names(rast_stack))

missing_layers <- setdiff(selected_vars, names(rast_stack))
if (length(missing_layers) > 0) {
  stop(paste(
    "Las siguientes capas NO existen en el raster stack y el RF las requiere:",
    paste(missing_layers, collapse = ", ")
  ))
}

trend_stack <- rast_stack[[selected_vars]]

# Predict con manejo de filas all-NA
trend_raster <- try(
  terra::predict(
    trend_stack,
    rf_fit_full,
    na.rm = TRUE,
    fun = function(model, data) {
      df <- as.data.frame(data)
      mask_all_na <- apply(df, 1, function(r) all(is.na(r)))
      out <- rep(NA_real_, nrow(df))
      if (any(!mask_all_na)) {
        df_valid <- df[!mask_all_na, , drop = FALSE]
        preds_valid <- predict(model, df_valid)
        out[!mask_all_na] <- preds_valid
      }
      return(out)
    }
  )
)
if (inherits(trend_raster, "try-error")) {
  warning("terra::predict con randomForest fall√≥ ‚Äî usando raster::predict como alternativa.")
  r_stack_r <- raster::stack()
  for (v in selected_vars) {
    r_stack_r <- raster::addLayer(r_stack_r, raster::raster(rast_stack[[v]]))
  }
  names(r_stack_r) <- selected_vars
  trend_raster_r <- raster::predict(r_stack_r, rf_fit_full, na.rm = TRUE)
  trend_raster <- terra::rast(trend_raster_r)
}

trend_outfile <- file.path(out_folder, "trend_RF.tif")
terra::writeRaster(trend_raster, trend_outfile, overwrite = TRUE)
cat("‚úÖ Raster de tendencia (Random Forest final) guardado en:\n", trend_outfile, "\n")
```

# 12. Calcular residuos en los puntos usando el modelo full

```{r}
pred_full_on_points <- predict(rf_fit_full, newdata = x_full)
residuals_full <- y_full - pred_full_on_points

# Preparar objeto espacial para gstat (usar sp)
coords_all <- sf::st_coordinates(pts_sf)[complete_cases, , drop = FALSE]
proj4_str <- try(terra::crs(rast_stack), silent = TRUE)
if (is.na(proj4_str) || length(proj4_str) == 0) proj4_str <- NA_character_
pts_sp <- sp::SpatialPointsDataFrame(
  coords = coords_all, data = data.frame(resid = residuals_full),
  proj4string = sp::CRS(proj4_str)
)
```

# 13. Variograma experimental y AUTO-SELECCI√ìN DEL MEJOR MODELO

```{r}
vgm_emp <- gstat::variogram(resid ~ 1, data = pts_sp)

# Estimaciones iniciales
initial_sill <- var(residuals_full, na.rm = TRUE)
initial_range <- max(sp::spDists(as.matrix(coords_all), longlat = FALSE)) / 3
initial_nugget <- initial_sill * 0.05

vgm_results <- list()
sse_values <- setNames(rep(NA_real_, length(model_candidates)), model_candidates)

# Probar cada candidato
for (m in model_candidates) {
  vgm_init <- gstat::vgm(psill = initial_sill, model = m, range = initial_range, nugget = initial_nugget)
  vgm_fit_try <- try(
    gstat::fit.variogram(
      vgm_emp,
      vgm_init,
      fit.method = 6, # m√©todo robusto
      maxit = 400
    ),
    silent = TRUE
  )

  if (!inherits(vgm_fit_try, "try-error")) {
    sse <- try(attr(vgm_fit_try, "SSErr"), silent = TRUE)
    if (inherits(sse, "try-error") || is.null(sse)) sse <- NA_real_
    vgm_results[[m]] <- vgm_fit_try
    sse_values[m] <- sse
  } else {
    sse_values[m] <- NA_real_
  }
}

# Seleccionar el mejor (m√≠nimo SSE v√°lido)
valid_sse <- sse_values[!is.na(sse_values)]
if (length(valid_sse) == 0) {
  warning("‚ùå Ning√∫n modelo de variograma logr√≥ ajuste ‚Äî se usar√° el modelo esf√©rico por defecto.")
  best_model_name <- "Sph"
  vgm_fit <- gstat::vgm(psill = initial_sill, model = best_model_name, range = initial_range, nugget = initial_nugget)
} else {
  best_model_name <- names(valid_sse)[which.min(valid_sse)]
  vgm_fit <- vgm_results[[best_model_name]]
  message(paste0(
    "‚úÖ Mejor modelo de variograma seleccionado: ", best_model_name,
    " (SSE = ", round(min(valid_sse), 6), ")"
  ))
}

print(vgm_emp)
print(vgm_fit)

# Guardar variograma emp√≠rico
vgm_emp_df <- as.data.frame(vgm_emp)
readr::write_csv(vgm_emp_df, file.path(out_folder, "variograma_empirico.csv"))
cat("Variograma emp√≠rico guardado en:", file.path(out_folder, "variograma_empirico.csv"), "\n")

# --------- Extracci√≥n de par√°metros del modelo seleccionado ---------------
vgm_fit_df <- try(as.data.frame(vgm_fit), silent = TRUE)

nugget_val <- NA_real_
psill_val <- NA_real_
range_val <- NA_real_
model_name <- best_model_name

if (!inherits(vgm_fit_df, "try-error") && nrow(vgm_fit_df) > 0) {
  if (any(grepl("Nug", vgm_fit_df$model, ignore.case = TRUE))) {
    nugget_val <- vgm_fit_df$psill[grepl("Nug", vgm_fit_df$model, ignore.case = TRUE)][1]
  } else if (any(vgm_fit_df$range == 0, na.rm = TRUE)) {
    nugget_val <- vgm_fit_df$psill[which(vgm_fit_df$range == 0)[1]]
  } else {
    nugget_val <- 0
  }

  non_nug_rows <- which(!grepl("Nug", vgm_fit_df$model, ignore.case = TRUE))
  if (length(non_nug_rows) > 0) {
    idx <- non_nug_rows[1]
    psill_val <- vgm_fit_df$psill[idx]
    range_val <- vgm_fit_df$range[idx]
    model_name <- as.character(vgm_fit_df$model[idx])
  } else {
    psill_val <- vgm_fit_df$psill[1]
    range_val <- vgm_fit_df$range[1]
    model_name <- as.character(vgm_fit_df$model[1])
  }
}

sill_val <- sum(c(nugget_val, psill_val), na.rm = TRUE)
PSV <- if (!is.na(psill_val) && !is.na(sill_val) && sill_val > 0) (psill_val / sill_val) * 100 else NA_real_

vgm_params_table <- data.frame(
  model = model_name,
  nugget = nugget_val,
  psill = psill_val,
  sill = sill_val,
  range = range_val,
  PSV_pct = PSV,
  stringsAsFactors = FALSE
)

readr::write_csv(vgm_params_table, file.path(out_folder, "variograma_parametros.csv"))
cat("üìå Par√°metros del variograma guardados en:", file.path(out_folder, "variograma_parametros.csv"), "\n")

# Gr√°fico PNG variograma emp√≠rico + ajuste
vg_png <- file.path(out_folder, "variograma_empirico_ajustado.png")
png(filename = vg_png, width = 900, height = 700)
try(
  {
    plot(vgm_emp, vgm_fit,
      main = paste("Variograma emp√≠rico y ajuste (", model_name, ")"),
      xlab = "Distancia", ylab = "Semivarianza"
    )
  },
  silent = TRUE
)
dev.off()
cat("üìç Gr√°fico del variograma guardado en:", vg_png, "\n")

# 13.3 Validaci√≥n cruzada LOO de Kriging sobre los puntos (krige.cv)
cv_krig <- try(gstat::krige.cv(formula = resid ~ 1, locations = pts_sp, model = vgm_fit, nmax = 30), silent = TRUE)
if (inherits(cv_krig, "try-error")) {
  warning("krige.cv fall√≥. No se pudieron calcular m√©tricas LOO de kriging.")
  cv_krig <- NULL
}

# 13.4 Calcular m√©tricas (MAE, RMSE, R2, PBIAS) entre resid_obs y resid_cv_pred
krig_cv_metrics <- data.frame(MAE = NA_real_, RMSE = NA_real_, BIAS = NA_real_, R2 = NA_real_, PBIAS_pct = NA_real_, n = NA_integer_)

if (!is.null(cv_krig)) {
  pred_col_name <- names(cv_krig)[grepl("pred", names(cv_krig), ignore.case = TRUE)][1]
  if (is.null(pred_col_name) || length(pred_col_name) == 0 || is.na(pred_col_name)) {
    if ("var1.pred" %in% names(cv_krig)) {
      pred_col_name <- "var1.pred"
    } else if ("resid.pred" %in% names(cv_krig)) pred_col_name <- "resid.pred"
  }
  pred_vals <- cv_krig[[pred_col_name]]
  obs_vals <- residuals_full
  n_obs <- min(length(obs_vals), length(pred_vals))
  obs_vals <- obs_vals[1:n_obs]
  pred_vals <- pred_vals[1:n_obs]

  mae_krig <- Metrics::mae(obs_vals, pred_vals)
  rmse_krig <- Metrics::rmse(obs_vals, pred_vals)
  bias_krig <- mean(pred_vals - obs_vals, na.rm = TRUE)
  r2_krig <- try(cor(obs_vals, pred_vals, use = "complete.obs")^2, silent = TRUE)
  if (inherits(r2_krig, "try-error")) r2_krig <- NA_real_
  pbias_krig <- 100 * sum(pred_vals - obs_vals, na.rm = TRUE) / sum(obs_vals, na.rm = TRUE)

  krig_cv_metrics <- data.frame(
    MAE = mae_krig,
    RMSE = rmse_krig,
    BIAS = bias_krig,
    R2 = r2_krig,
    PBIAS_pct = pbias_krig,
    n = n_obs
  )

  # Exportar resultados krige.cv (detallado) y m√©tricas
  cv_krig_df <- as.data.frame(cv_krig)
  readr::write_csv(cv_krig_df, file.path(out_folder, "krige_cv_detailed.csv"))
  readr::write_csv(krig_cv_metrics, file.path(out_folder, "krige_cv_metrics_summary.csv"))
  cat("Resultados krige.cv y m√©tricas guardadas en:", out_folder, "\n")
} else {
  cat("No se generaron m√©tricas de kriging (cv_krig es NULL).\n")
}
```

# 14. Preparar grilla para kriging (usar la estructura del raster)

```{r}
template_r <- raster::raster(expected_files[1])
grid_sp <- as(template_r, "SpatialGridDataFrame")
```

# 15. Kriging ordinario de residuos

```{r}
gstat_obj <- gstat::gstat(id = "resid", formula = resid ~ 1, data = pts_sp, model = vgm_fit)
krig_res <- predict(gstat_obj, newdata = grid_sp)

# Convertir a raster y alinear con trend_raster
krig_raster_r <- raster::raster(krig_res["resid.pred"])
krig_raster <- terra::rast(krig_raster_r)
krig_outfile <- file.path(out_folder, "kriging_residuals.tif")
krig_raster <- terra::resample(krig_raster, trend_raster, method = "bilinear")
terra::writeRaster(krig_raster, krig_outfile, overwrite = TRUE)
cat("Raster de residuos krigeados guardado en:", krig_outfile, "\n")
```

# 16. Sumar tendencia + residuos krigeados = Regression Kriging

```{r}
rk_raster <- trend_raster + krig_raster
rk_outfile <- file.path(out_folder, "RK_SQIw_final.tif")
terra::writeRaster(rk_raster, rk_outfile, overwrite = TRUE)
cat("Raster final Regression Kriging guardado en:", rk_outfile, "\n")

# Adicional: guardar PNG del mapa final (plot del raster)
rk_png <- file.path(out_folder, "RK_SQIw_final.png")
png(filename = rk_png, width = 1000, height = 800)
try(
  {
    plot(rk_raster, main = "Regression Kriging - SQIw final")
  },
  silent = TRUE
)
dev.off()
cat("PNG del raster final guardado en:", rk_png, "\n")
```

# 17. Exportar tablas de CV, m√©tricas y gr√°ficos

```{r}
# 17.1 M√©tricas CV (del entrenamiento) - RF (CV interno)
cv_rmse <- sqrt(mean((cv_df$pred - cv_df$obs)^2, na.rm = TRUE))
cv_bias <- mean(cv_df$pred - cv_df$obs, na.rm = TRUE)
cv_r2 <- cor(cv_df$pred, cv_df$obs, use = "complete.obs")^2
cv_n <- nrow(cv_df)
cv_mae <- Metrics::mae(cv_df$obs, cv_df$pred)

metrics_cv_rf <- data.frame(
  Method = "RF_CV",
  RMSE = cv_rmse,
  MAE = cv_mae,
  BIAS = cv_bias,
  R2 = cv_r2,
  PBIAS_pct = 100 * sum(cv_df$pred - cv_df$obs, na.rm = TRUE) / sum(cv_df$obs, na.rm = TRUE),
  n = cv_n,
  stringsAsFactors = FALSE
)

# 17.2 Preparar la fila Kriging (si se calcul√≥)
metrics_cv_krig <- data.frame(
  Method = "Krig_CV",
  RMSE = if (!is.null(cv_krig)) krig_cv_metrics$RMSE else NA_real_,
  MAE = if (!is.null(cv_krig)) krig_cv_metrics$MAE else NA_real_,
  BIAS = if (!is.null(cv_krig)) krig_cv_metrics$BIAS else NA_real_,
  R2 = if (!is.null(cv_krig)) krig_cv_metrics$R2 else NA_real_,
  PBIAS_pct = if (!is.null(cv_krig)) krig_cv_metrics$PBIAS_pct else NA_real_,
  n = if (!is.null(cv_krig)) krig_cv_metrics$n else NA_integer_,
  stringsAsFactors = FALSE
)

# 17.3 Agregar columnas de variograma a la fila Kriging (y a RF con NA)
vg_cols <- data.frame(
  Nugget = vgm_params_table$nugget,
  Psill = vgm_params_table$psill,
  Sill = vgm_params_table$sill,
  Range = vgm_params_table$range,
  PSV_pct = vgm_params_table$PSV_pct,
  stringsAsFactors = FALSE
)

metrics_cv_rf_full <- cbind(metrics_cv_rf, vg_cols[rep(1, nrow(metrics_cv_rf)), , drop = FALSE])
metrics_cv_krig_full <- cbind(metrics_cv_krig, vg_cols)

# 17.4 Unir filas RF_CV y Krig_CV y guardar en cv_metrics_summary.csv
cv_metrics_summary <- rbind(metrics_cv_rf_full, metrics_cv_krig_full)

# Renombrar columnas a estilo 'opci√≥n 2' (guion bajo)
names(cv_metrics_summary) <- c(
  "Method", "RMSE", "MAE", "BIAS", "R2", "PBIAS_pct", "n",
  "Nugget", "Psill", "Sill", "Range", "PSV_pct"
)

readr::write_csv(cv_metrics_summary, file.path(out_folder, "cv_metrics_summary.csv"))
cat("Archivo central cv_metrics_summary.csv guardado en:", file.path(out_folder, "cv_metrics_summary.csv"), "\n")

# 17.5 Guardar tablas auxiliares
readr::write_csv(cv_df, file.path(out_folder, "cv_predictions_detailed.csv"))
readr::write_csv(pts_df, file.path(out_folder, "points_with_predictors_and_response.csv"))

# 17.6 Gr√°ficos Observed vs Pred - Test y CV
p_test <- ggplot2::ggplot(data = test_table, aes(x = observed, y = predicted)) +
  geom_point() +
  geom_abline(slope = 1, intercept = 0, linetype = "dashed") +
  ggtitle("Observed vs Predicted (Test 20%)") +
  xlab("Observado") +
  ylab("Predicho")
ggsave(filename = file.path(out_folder, "obs_vs_pred_test.png"), plot = p_test, width = 6, height = 5)

p_cv <- ggplot2::ggplot(data = cv_df, aes(x = obs, y = pred)) +
  geom_point() +
  geom_abline(slope = 1, intercept = 0, linetype = "dashed") +
  ggtitle("Observed vs Predicted (CV interno train)") +
  xlab("Observado") +
  ylab("Predicho")
ggsave(filename = file.path(out_folder, "obs_vs_pred_cv.png"), plot = p_cv, width = 6, height = 5)
```

# 18. Resumen final y archivos

```{r}
cat("\n--- Proceso completado ---\n")
cat("Archivos exportados en:", normalizePath(out_folder), "\n")
cat("- trend_RF.tif\n- kriging_residuals.tif\n- RK_SQIw_final.tif (GeoTIFF)\n- RK_SQIw_final.png (PNG)\n- cv_predictions_train.csv (detallado)\n- cv_metrics_summary.csv (RF_CV + Krig_CV)\n- krige_cv_detailed.csv\n- krige_cv_metrics_summary.csv\n- variograma_empirico.csv\n- variograma_parametros.csv\n- variograma_empirico_ajustado.png\n- test_predicted_vs_observed.csv\n- obs_vs_pred_test.png\n- obs_vs_pred_cv.png\n\n")

# (Opcional) Mostrar mapas interactivos si est√°s en entorno con GUI
if (requireNamespace("mapview", quietly = TRUE)) {
  try(
    {
      mapview::mapview(trend_raster, layer.name = "Tendencia_RF") +
        mapview::mapview(krig_raster, layer.name = "Residuos_Kriging") +
        mapview::mapview(rk_raster, layer.name = "SQIw_Final")
    },
    silent = TRUE
  )
}
```


# References

Broman, K. W., & Woo, K. H. (2017). Data organization in spreadsheets. The American Statistician, 72(1), 2‚Äì10. https://doi.org/10.1080/00031305.2017.1375989

Zuur, A. F., Ieno, E. N., & Elphick, C. S. (2009). A protocol for data exploration to avoid common statistical problems. Methods in Ecology and Evolution, 1(1), 3‚Äì14. https://doi.org/10.1111/j.2041-210x.2009.00001.x

Francoishusson. (2017, July 13). PCA course using FactoMineR | R-bloggers. R-bloggers. https://www.r-bloggers.com/2017/07/pca-course-using-factominer/

Kozak, M., & Piepho, H. (2017). What‚Äôs normal anyway? Residual plots are more telling than significance tests when checking ANOVA assumptions. Journal of Agronomy and Crop Science, 204(1), 86‚Äì98. https://doi.org/10.1111/jac.12220

Tanaka, E., & Hui, F. K. C. (2019). Symbolic formulae for linear mixed models. In Communications in computer and information science (pp. 3‚Äì21). https://doi.org/10.1007/978-981-15-1960-4_1

Schielzeth, H., Dingemanse, N. J., Nakagawa, S., Westneat, D. F., Allegue, H., Teplitsky, C., R√©ale, D., Dochtermann, N. A., Garamszegi, L. Z., & Araya‚ÄêAjoy, Y. G. (2020). Robustness of linear mixed‚Äêeffects models to violations of distributional assumptions. Methods in Ecology and Evolution, 11(9), 1141‚Äì1152. https://doi.org/10.1111/2041-210x.13434
